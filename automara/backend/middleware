// backend/src/server.js
// Main Express server with comprehensive multi-tenant architecture

const express = require('express');
const helmet = require('helmet');
const cors = require('cors');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');
const supertokens = require('supertokens-node');
const Session = require('supertokens-node/recipe/session');
const EmailPassword = require('supertokens-node/recipe/emailpassword');
const ThirdParty = require('supertokens-node/recipe/thirdparty');
const MultiFactorAuth = require('supertokens-node/recipe/multifactorauth');
const { middleware, errorHandler } = require('supertokens-node/framework/express');
const swaggerUi = require('swagger-ui-express');
const { Pool } = require('pg');
const crypto = require('crypto');

// Import routes
const tenantRoutes = require('./routes/tenants');
const workflowRoutes = require('./routes/workflows');
const apiKeyRoutes = require('./routes/apiKeys');
const webhookRoutes = require('./routes/webhooks');
const stripeRoutes = require('./routes/stripe');
const m365Routes = require('./routes/m365');

// Import middleware
const { tenantMiddleware } = require('./middleware/tenant');
const { auditLogger } = require('./middleware/audit');

// Import services
const { initializeN8N } = require('./services/n8n');
const swaggerSpec = require('./config/swagger');

const app = express();
const PORT = process.env.PORT || 4000;

// Database connection pool
const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
    ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false,
    max: 20,
    idleTimeoutMillis: 30000,
    connectionTimeoutMillis: 2000,
});

// Make pool available globally
global.db = pool;

// Initialize SuperTokens
supertokens.init({
    framework: 'express',
    supertokens: {
        connectionURI: process.env.SUPERTOKENS_CONNECTION_URI,
        apiKey: process.env.SUPERTOKENS_API_KEY,
    },
    appInfo: {
        appName: 'Automara',
        apiDomain: process.env.API_DOMAIN,
        websiteDomain: process.env.FRONTEND_URL,
        apiBasePath: '/auth',
        websiteBasePath: '/auth',
    },
    recipeList: [
        EmailPassword.init({
            signUpFeature: {
                formFields: [
                    { id: 'email' },
                    { id: 'password' },
                    { id: 'tenantId', optional: true },
                ],
            },
        }),
        ThirdParty.init({
            signInAndUpFeature: {
                providers: [
                    // Can add Google, Microsoft SSO later
                ],
            },
        }),
        MultiFactorAuth.init({
            firstFactors: ['emailpassword'],
        }),
        Session.init({
            jwt: {
                enable: true,
            },
            override: {
                functions: (originalImplementation) => ({
                    ...originalImplementation,
                    createNewSession: async function (input) {
                        // Add tenant_id to JWT payload
                        const tenantId = input.userContext?.tenantId;
                        input.accessTokenPayload = {
                            ...input.accessTokenPayload,
                            tenantId,
                        };
                        return originalImplementation.createNewSession(input);
                    },
                }),
            },
        }),
    ],
});

// Security middleware
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", 'data:', 'https:'],
        },
    },
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true,
    },
}));

// CORS configuration
app.use(cors({
    origin: [process.env.FRONTEND_URL, 'http://localhost:3000'],
    credentials: true,
    methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
    allowedHeaders: ['Content-Type', 'Authorization', 'X-Tenant-ID', 'rid', 'fdi-version', 'anti-csrf'],
}));

// Body parsing
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Logging
if (process.env.NODE_ENV !== 'test') {
    app.use(morgan('combined'));
}

// Rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // limit each IP to 100 requests per windowMs
    message: 'Too many requests from this IP, please try again later.',
    standardHeaders: true,
    legacyHeaders: false,
});
app.use('/api/', limiter);

// SuperTokens middleware
app.use(middleware());

// Health check endpoint
app.get('/health', (req, res) => {
    res.status(200).json({ 
        status: 'healthy', 
        timestamp: new Date().toISOString(),
        service: 'Automara API',
    });
});

// API Documentation
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec, {
    customCss: '.swagger-ui .topbar { display: none }',
    customSiteTitle: 'Automara API Documentation',
}));

// Routes with tenant middleware
app.use('/api/tenants', tenantRoutes);
app.use('/api/workflows', tenantMiddleware, auditLogger, workflowRoutes);
app.use('/api/keys', tenantMiddleware, auditLogger, apiKeyRoutes);
app.use('/api/m365', tenantMiddleware, auditLogger, m365Routes);
app.use('/api/stripe', stripeRoutes);

// Webhook routes (no auth required, but signature verification)
app.use('/webhooks', webhookRoutes);

// SuperTokens error handler
app.use(errorHandler());

// Global error handler
app.use((err, req, res, next) => {
    console.error('Error:', err);
    
    // Don't expose internal errors in production
    const statusCode = err.statusCode || 500;
    const message = process.env.NODE_ENV === 'production' && statusCode === 500
        ? 'Internal server error'
        : err.message;
    
    res.status(statusCode).json({
        error: {
            message,
            ...(process.env.NODE_ENV !== 'production' && { stack: err.stack }),
        },
    });
});

// 404 handler
app.use((req, res) => {
    res.status(404).json({ error: 'Route not found' });
});

// Graceful shutdown
process.on('SIGTERM', async () => {
    console.log('SIGTERM signal received: closing HTTP server');
    await pool.end();
    process.exit(0);
});

process.on('SIGINT', async () => {
    console.log('SIGINT signal received: closing HTTP server');
    await pool.end();
    process.exit(0);
});

// Start server
const server = app.listen(PORT, async () => {
    console.log(`ðŸš€ Automara API running on port ${PORT}`);
    console.log(`ðŸ“š API Documentation: http://localhost:${PORT}/api-docs`);
    console.log(`ðŸ¥ Health check: http://localhost:${PORT}/health`);
    
    try {
        // Test database connection
        const client = await pool.connect();
        console.log('âœ… Database connected successfully');
        client.release();
        
        // Initialize N8N connection
        await initializeN8N();
        console.log('âœ… N8N service initialized');
    } catch (err) {
        console.error('âŒ Startup error:', err);
    }
});

module.exports = { app, server };


// backend/src/middleware/tenant.js
// Tenant isolation middleware - ensures all requests are scoped to a tenant

const { verifySession } = require('supertokens-node/recipe/session/framework/express');
const crypto = require('crypto');

// Extract tenant ID from JWT or header
const tenantMiddleware = async (req, res, next) => {
    try {
        // First verify the session
        await verifySession()(req, res, async () => {
            const session = req.session;
            
            // Get tenant ID from JWT payload
            let tenantId = session.getAccessTokenPayload().tenantId;
            
            // Alternatively, check header (for API key access)
            if (!tenantId && req.headers['x-tenant-id']) {
                tenantId = req.headers['x-tenant-id'];
            }
            
            if (!tenantId) {
                return res.status(403).json({ 
                    error: 'Tenant ID required',
                    message: 'No tenant context found in session or headers',
                });
            }
            
            // Fetch tenant details and verify it's active
            const tenantResult = await global.db.query(
                'SELECT id, schema_name, status FROM public.tenants WHERE id = $1',
                [tenantId]
            );
            
            if (tenantResult.rows.length === 0) {
                return res.status(404).json({ error: 'Tenant not found' });
            }
            
            const tenant = tenantResult.rows[0];
            
            if (tenant.status !== 'active') {
                return res.status(403).json({ 
                    error: 'Tenant inactive',
                    message: 'Your account is not active. Please contact support.',
                });
            }
            
            // Attach tenant info to request
            req.tenant = tenant;
            req.tenantId = tenantId;
            req.schemaName = tenant.schema_name;
            
            // Set search path for this request to isolate queries
            await global.db.query(`SET search_path TO ${tenant.schema_name}, public`);
            
            next();
        });
    } catch (err) {
        console.error('Tenant middleware error:', err);
        return res.status(500).json({ error: 'Failed to verify tenant context' });
    }
};

// Middleware to verify tenant ownership of resources
const verifyResourceOwnership = (resourceTable, resourceIdParam = 'id') => {
    return async (req, res, next) => {
        const resourceId = req.params[resourceIdParam];
        const schemaName = req.schemaName;
        
        try {
            const result = await global.db.query(
                `SELECT id FROM ${schemaName}.${resourceTable} WHERE id = $1`,
                [resourceId]
            );
            
            if (result.rows.length === 0) {
                return res.status(404).json({ 
                    error: 'Resource not found',
                    message: `${resourceTable} with ID ${resourceId} not found in your account`,
                });
            }
            
            next();
        } catch (err) {
            console.error('Resource ownership verification error:', err);
            return res.status(500).json({ error: 'Failed to verify resource ownership' });
        }
    };
};

module.exports = { tenantMiddleware, verifyResourceOwnership };


// backend/src/middleware/audit.js
// Audit logging middleware for compliance and security

const auditLogger = async (req, res, next) => {
    const startTime = Date.now();
    
    // Capture the original res.json to log response
    const originalJson = res.json.bind(res);
    res.json = (body) => {
        res.locals.responseBody = body;
        return originalJson(body);
    };
    
    // Continue with request
    res.on('finish', async () => {
        // Only log if tenant context exists
        if (!req.tenant) return;
        
        const duration = Date.now() - startTime;
        const userId = req.session?.getUserId();
        
        const auditLog = {
            user_id: userId || null,
            action: `${req.method} ${req.path}`,
            resource_type: req.path.split('/')[2] || null,
            resource_id: req.params.id || null,
            ip_address: req.ip || req.connection.remoteAddress,
            user_agent: req.get('user-agent'),
            status_code: res.statusCode,
            duration_ms: duration,
            changes: {
                method: req.method,
                body: req.body,
                query: req.query,
                response_status: res.statusCode,
            },
        };
        
        try {
            await global.db.query(
                `INSERT INTO ${req.schemaName}.audit_logs 
                (user_id, action, resource_type, resource_id, ip_address, user_agent, changes) 
                VALUES ($1, $2, $3, $4, $5, $6, $7)`,
                [
                    auditLog.user_id,
                    auditLog.action,
                    auditLog.resource_type,
                    auditLog.resource_id,
                    auditLog.ip_address,
                    auditLog.user_agent,
                    JSON.stringify(auditLog.changes),
                ]
            );
        } catch (err) {
            console.error('Audit logging error:', err);
            // Don't fail the request if audit logging fails
        }
    });
    
    next();
};

module.exports = { auditLogger };


// backend/src/services/encryption.js
// AES encryption service for sensitive data

const crypto = require('crypto');

const ENCRYPTION_KEY = process.env.DB_ENCRYPTION_KEY;
const ALGORITHM = 'aes-256-gcm';
const IV_LENGTH = 16;
const SALT_LENGTH = 64;
const TAG_LENGTH = 16;
const TAG_POSITION = SALT_LENGTH + IV_LENGTH;
const ENCRYPTED_POSITION = TAG_POSITION + TAG_LENGTH;

class EncryptionService {
    /**
     * Encrypts text using AES-256-GCM
     * @param {string} text - Plain text to encrypt
     * @returns {string} - Base64 encoded encrypted data
     */
    static encrypt(text) {
        if (!text) return null;
        
        const iv = crypto.randomBytes(IV_LENGTH);
        const salt = crypto.randomBytes(SALT_LENGTH);
        
        const key = crypto.pbkdf2Sync(
            ENCRYPTION_KEY,
            salt,
            100000,
            32,
            'sha512'
        );
        
        const cipher = crypto.createCipheriv(ALGORITHM, key, iv);
        const encrypted = Buffer.concat([
            cipher.update(String(text), 'utf8'),
            cipher.final(),
        ]);
        
        const tag = cipher.getAuthTag();
        
        const result = Buffer.concat([salt, iv, tag, encrypted]);
        return result.toString('base64');
    }
    
    /**
     * Decrypts AES-256-GCM encrypted text
     * @param {string} encryptedData - Base64 encoded encrypted data
     * @returns {string} - Decrypted plain text
     */
    static decrypt(encryptedData) {
        if (!encryptedData) return null;
        
        try {
            const buffer = Buffer.from(encryptedData, 'base64');
            
            const salt = buffer.slice(0, SALT_LENGTH);
            const iv = buffer.slice(SALT_LENGTH, TAG_POSITION);
            const tag = buffer.slice(TAG_POSITION, ENCRYPTED_POSITION);
            const encrypted = buffer.slice(ENCRYPTED_POSITION);
            
            const key = crypto.pbkdf2Sync(
                ENCRYPTION_KEY,
                salt,
                100000,
                32,
                'sha512'
            );
            
            const decipher = crypto.createDecipheriv(ALGORITHM, key, iv);
            decipher.setAuthTag(tag);
            
            const decrypted = decipher.update(encrypted) + decipher.final('utf8');
            return decrypted;
        } catch (err) {
            console.error('Decryption error:', err);
            return null;
        }
    }
    
    /**
     * Generates a secure random token
     * @param {number} length - Token length in bytes
     * @returns {string} - Hex encoded token
     */
    static generateToken(length = 32) {
        return crypto.randomBytes(length).toString('hex');
    }
    
    /**
     * Creates HMAC signature for webhook verification
     * @param {string} payload - Payload to sign
     * @param {string} secret - Secret key
     * @returns {string} - Hex encoded signature
     */
    static signPayload(payload, secret) {
        return crypto
            .createHmac('sha256', secret)
            .update(typeof payload === 'string' ? payload : JSON.stringify(payload))
            .digest('hex');
    }
    
    /**
     * Verifies HMAC signature
     * @param {string} payload - Original payload
     * @param {string} signature - Signature to verify
     * @param {string} secret - Secret key
     * @returns {boolean} - True if signature is valid
     */
    static verifySignature(payload, signature, secret) {
        const expectedSignature = this.signPayload(payload, secret);
        return crypto.timingSafeEqual(
            Buffer.from(signature),
            Buffer.from(expectedSignature)
        );
    }
}

module.exports = EncryptionService;
